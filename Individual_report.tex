% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[12pt]{article}
\usepackage[top=2.2cm, left=2.2cm, bottom=1.6cm, right=1.8cm]{geometry} % Custom margins

\usepackage{pdfpages}
\usepackage{appendix}

\usepackage{listings}
\usepackage{xcolor}

\lstset{
	language=C++,  % Set the language
	basicstyle=\ttfamily\small,  % Font style
	breaklines=true,  % Automatic line breaking
	breakatwhitespace=false,  % Break lines at whitespace
	postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},  % Mark where text has been broken
	captionpos=b,  % Caption at the bottom
	numbers=left,  % Line numbers on the left
	numberstyle=\tiny\color{gray},  % Styling for the line numbers
	numbersep=5pt,  % Reduced space between line numbers and code
	xleftmargin=5pt,  % Margin on the left outside the frame
	frame=none,  % No frame around the code
	framesep=0pt,  % No padding between frame and code, irrelevant now without frame
	showstringspaces=false,  % Don't show spaces in strings with special character
	tabsize=4,  % Size of tabs
	% linewidth=\textwidth  % Removed as this is not a valid option
}

\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
  \usepackage{fontspec}
  \setmainfont{Carlito}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\title{Individual Project

Final Report}
\author{}
\date{}

\begin{document}
\maketitle

ID Number: B820928

Programme: Electronic and Electrical Engineering MEng

Module Code: 23WSD030/23WS50META

Project Title: Thread by Thread: Benchmarking and Comparing the Executions of Multi-threaded Applications on Multi-core Architectures.

Abstract:
Your abstract here

\newpage
\tableofcontents
\newpage

\section{Introduction(3-5 pages)}
The objective of this project is to enhance the performance of specific applications through parallel computing and to examine their efficiency on both desktop and embedded central processing units (CPUs). Parallel computing is a methodology employed in software development that enables certain segments of code to execute simultaneously, thereby diminishing the overall execution time of an application and augmenting its scalability. Contemporary processors boast a multi-core architecture, integrating multiple CPUs within a single chip, which is pivotal for facilitating parallelism.  

Parallelism can be achieved via multi-threading and multi-processing techniques. A process refers to an active instance of a computer program, encompassing the program's code and its ongoing activities. Each process operates within its distinct memory address space and system resources, maintaining independence from other processes. However, processes can engage in communication with one another through various inter-process communication (IPC) mechanisms. Conversely, a thread represents the minimal unit of processing within a process. It executes within a process's context, sharing the processâ€™s resources like memory and file descriptors, yet it retains its distinct execution state, including the program counter, register set, and stack. Threads can facilitate the parallel execution of code segments within a single process. 

Multi-processing involves an application initiating multiple processes to perform parallel operations, whereas multi-threading pertains to an application that generates multiple threads usually within a single process. This project concentrates on three main applications: the initial two are optimised utilizing multi-threading and their outcomes are assessed on both desktop and embedded processors. The embedded processors examined in this study include the Raspberry Pi 5, 4, and 3, with the Raspberry Pi 5 representing the forefront of technology as of 2024. The final application is a graphical user interface (GUI) application, where multi-processing is employed to attain parallelism. This application was developed by Alex Henneman, a Ph.D. student, under the supervision of Dr. Luciano Ost. The aim here is to refine this application to minimize its execution time and enhance its scalability. 

The inaugural objective of the main project focuses on the enhancement of a multi-core benchmark application named \texttt{mpbenchmark}. The essence of \texttt{mpbenchmark} lies in its capability to simulate real-time calculations of jet engine thermodynamics, serving as a multi-threaded tool to evaluate the multi-core performance of CPUs. This application represents an advanced iteration of its predecessor, \texttt{JetBench}. Initially crafted in \texttt{C} utilizing the \texttt{OpenMP} library, \texttt{JetBench} exhibited certain limitations inherent to its design and programming language. The evolution from \texttt{JetBench} to \texttt{mpbenchmark} marked a significant enhancement, rectifying the previous version's shortcomings. Moreover, \texttt{mpbenchmark} expanded its foundation by incorporating additional programming languages, including \texttt{Ada}, \texttt{C\#}, and \texttt{Java}. Despite this diversification, the implementations in \texttt{C} and \texttt{Ada} were identified as the most performant. However, it's noteworthy that the \texttt{C} and \texttt{Ada} versions of \texttt{mpbenchmark} still encounter language-specific constraints. Specifically, \texttt{C}'s lack of object-oriented capabilities, the requirement for manual memory management, and the absence of libraries for frequently utilized data structures and algorithms pose significant drawbacks. \texttt{Ada}, while offering some advantages, remains a specialized language predominantly employed within the defence and aerospace sectors. To transcend these limitations, this project aspires to develop a modernized version of \texttt{mpbenchmark} utilizing \texttt{C++}. This choice is motivated by \texttt{C++}'s ability to mitigate many of the challenges inherent to \texttt{C}, while still delivering comparable performance. The advent of \texttt{modern C++}, propelled by substantial updates to the core language post-2011, offers promising enhancements that are expected to refine \texttt{mpbenchmark}'s efficiency and functionality.

The secondary objective of this project centres on enhancing the performance of \texttt{MobileNet}, a specialised machine learning algorithm within the realm of convolutional neural networks (\texttt{CNNs}). \texttt{MobileNet} excels in the field of image classification, a process in which the algorithm is provided with an image and tasked with determining the image's corresponding class. While the intricate mathematical foundations and specific operational details of \texttt{MobileNet} are beyond the scope of this discussion, the primary focus is set on augmenting its efficiency. Originally designed as a sequential algorithm, \texttt{MobileNet} primarily operates on a single CPU core, which poses limitations on its execution speed and scalability. In pursuit of addressing these constraints, this project endeavours to transform the existing \texttt{C++} implementation of \texttt{MobileNet} into a multi-threaded architecture. By doing so, the aim is to significantly decrease its runtime and enhance its scalability, thereby optimizing the algorithm's performance for more robust and efficient image classification tasks. This effort to transition \texttt{MobileNet} from a sequential to a multi-threaded model represents a strategic move to leverage the capabilities of modern multi-core processors, ensuring a more responsive and efficient computational process.

The project's third objective is dedicated to the optimisation of a graphical user interface (\texttt{GUI}) application designed for microcontroller (\texttt{MCU}) testing, with a focus on minimising application runtime and bolstering its scalability. Named the \texttt{DeBaTE-FI} platform, this application is crafted in \texttt{Python} and leverages both multi-threading and multi-processing techniques to achieve parallelism and concurrency. It's crucial to distinguish between concurrency and parallelism; in a concurrent framework, tasks are initiated, executed, and completed in overlapping intervals, without necessitating simultaneous operation. The operational flow of the \texttt{DeBaTE-FI} platform involves the user connecting \texttt{MCUs} to a computer, after which the application dispatches specific commands to these \texttt{MCUs}. Following the transmission of commands, the platform awaits responses from the \texttt{MCUs} and proceeds to log the requisite data into output files. Among the three applications addressed in this project, the \texttt{DeBaTE-FI} platform emerges as the most intricate, a complexity attributable to both the scale and the sophisticated nature of its functions. This optimisation effort aims to streamline these extensive operations, enhancing the application's performance and user experience.

The structure of the report is organized as follows: it starts with a literature review, followed by methodology, results, and discussion sections. Appendices are provided after the conclusion for additional reference. The literature review section places the research within the existing body of knowledge by reviewing and interpreting relevant studies pertinent to the research question. This establishes a foundation for understanding the contributions of the project to the field. The methodology section outlines the strategies used to identify performance bottlenecks and potential optimization points within the software, including the introduction of new software designs. These are primarily illustrated through Unified Modeling Language (UML) diagrams and selected code snippets, offering a clear depiction of the proposed solutions. Following the methodology, the results and discussion sections report and analyse the findings from experiments conducted on both desktop and embedded processors, specifically targeting Raspberry Pi models 3 through 5. The findings are presented through benchmark runtime and speedup plots, providing a quantitative evaluation of the performance improvements. In the discussion section, the implications of these results are explored, evaluating the efficiency of the implemented optimizations and proposing directions for future research. This section seeks to provide an in-depth analysis that links the empirical findings with broader theoretical considerations. The appendices serve as a repository for supplementary materials, including details on the experimental PC setup, system specifications, and extended code snippets. These resources offer readers a deeper understanding of the technical aspects of the research, supporting the report's goals of transparency and reproducibility. 

\newpage
\section{Literature review(6-10 pages)}
\input{literature_review.tex}


\newpage
\section{Methodology(5-7 pages)}
\input{methodology.tex}

\section{Results and Discussion(8-10 pages)}

\subsection{Objective 1: \texttt{mpbenchmark}}
\subsection{Objective 2: \texttt{MobileNet}}
\subsection{Objective 3: \texttt{DeBaTE-FI platform}}

\section{Conclusion(2-4 pages)}

\bibliographystyle{IEEEtran}
\bibliography{references}
\addcontentsline{toc}{section}{References}  % Add this line


% Input the appendix file here
\begin{appendices}
	\input{appendix.tex}
\end{appendices}

\end{document}



