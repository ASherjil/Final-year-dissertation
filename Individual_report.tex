% Options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[12pt, openany]{book}
\usepackage[top=2.2cm, left=2.2cm, bottom=1.6cm, right=1.8cm]{geometry} % Custom margins

\usepackage{pdfpages}
\usepackage{appendix}

\usepackage{listings}
\usepackage{xcolor}

\usepackage{float}
\usepackage{array}  % for better column formatting

\usepackage{cite} % for IEEE citation format

% Adding titlesec package
\usepackage{titlesec}
\usepackage{tabularx} % for better table control

% Redefining the chapter title format
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing*{\chapter}{0pt}{-50pt}{10pt}

% Define colors for syntax highlighting
\definecolor{commentcolor}{gray}{0.5}
\definecolor{keywordcolor}{rgb}{0,0,1}
\definecolor{stringcolor}{rgb}{0.58,0,0.82}

\lstset{
	language=C++,  % Set the language
	basicstyle=\ttfamily\fontsize{10pt}{12pt}\selectfont,  % Set font style and size to 10pt with a normal line spacing of 12pt
	breaklines=true,  % Automatic line breaking
	captionpos=b,  % Caption at the bottom
	numbers=left,  % Line numbers on the left
	numberstyle=\tiny\color{gray},  % Styling for the line numbers
	numbersep=5pt,  % Space between line numbers and code
	xleftmargin=5pt,  % Margin on the left outside the frame
	frame=none,  % No frame around the code
	showstringspaces=false,  % Don't show spaces in strings with special character
	tabsize=4,  % Size of tabs
	commentstyle=\color{commentcolor}\ttfamily,
	keywordstyle=\color{keywordcolor}\bfseries\ttfamily,  % Bold for keywords
	stringstyle=\color{stringcolor}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}

\renewcommand{\bibname}{References}

\usepackage{fontspec}
\setmainfont{Carlito}

\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
  \usepackage{fontspec}
  \setmainfont{Carlito}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}

\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
	\IfFileExists{parskip.sty}{%
		\usepackage{parskip}
	}{% else
		\setlength{\parindent}{0pt}
		\setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
	\KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
	hidelinks,
	pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}

% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

% Include fancyhdr for header and footer customization
\usepackage{fancyhdr}

% Page style setup
\pagestyle{fancy}
\fancyhf{} % clear all header and footer fields
\fancyfoot[C]{\thepage} % put the page number in the center of the footer
\renewcommand{\headrulewidth}{0pt} % no line in header area
\renewcommand{\footrulewidth}{0pt} % no line in footer area

% Ensure the plain page style, used on chapter opening pages, is also empty
\fancypagestyle{plain}{
	\fancyhf{} % clear all header and footer fields for plain pages
	\fancyfoot[C]{\thepage} % page number in the center of the footer on plain pages
	\renewcommand{\headrulewidth}{0pt}
	\renewcommand{\footrulewidth}{0pt}
}



\usepackage{titlesec}

% Formatting the chapter title to remove "Chapter X"
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries}{}{0pt}{\Huge}


\begin{document}
\begin{titlepage}
	\centering
	% Title
	\vspace*{1cm} % Adjust the vertical space as needed
	{\Huge\bfseries Individual Project\\[0.5cm] Final Report\par}
	\vspace{2cm}
	% Reset centering to left-align the rest
	\raggedright
	% ID Number
	ID Number: B820928\par
	
	% Programme
	Programme: Electronic and Electrical Engineering MEng\par
	
	% Module Code
	Module Code: 23WSD030/23WS50META\par
	
	% Project Title
	Project Title: Thread by Thread: Benchmarking and Comparing the Executions of Multi-threaded Applications on Multi-core Architectures.\par
	
	% Abstract Heading
	\textbf{Abstract:}\par % Making 'Abstract' bold
	% Abstract Text
	% Background, aims, methods, results/conclusions.
	This dissertation examines the performance enhancements achievable through parallel computing techniques on multi-core architectures, particularly focusing on simultaneous multi-threading (SMT), also known as Intel’s Hyper-threading. The study optimizes three applications—\texttt{mpbenchmark}, a benchmark tool for multi-core CPUs; \texttt{MobileNet}, a machine learning framework for image classification; and \texttt{DeBaTE-FI}, a GUI application for testing microcontrollers against soft errors via telnet protocol. Enhancements include upgrading \texttt{mpbenchmark} to utilize modern C++ features and SIMD intrinsics, leading to improved design and scalability. \texttt{MobileNet} was transitioned from a single-threaded to a multi-threaded architecture using the \texttt{OpenMP} library, significantly boosting its efficiency. Debate-FI was optimized using Python’s multi-processing and threading capabilities, augmented by a newly developed high-performance \texttt{C++} library for telnet communication, replacing its outdated counterpart. Experimental results on desktop processors demonstrated minimal performance gains from SMT. Benchmarks on the Raspberry Pi 5 revealed substantial improvements: \texttt{mpbenchmark} and \texttt{MobileNet} exhibited performance increases of 75\% and 58\%, respectively, over the Raspberry Pi 4. The optimized \texttt{DeBaTE-FI} application achieved a 43.5-62.1\% reduction in runtime across various setups. Collectively, these results underscore the potential of tailored parallel computing strategies in enhancing the performance of both desktop and embedded systems, though the benefits of SMT were found to be limited. 
	
\end{titlepage}


\newpage
\tableofcontents

\chapter{Introduction(3-5 pages)}
The objective of this project is to enhance the performance of specific applications through parallel computing and to examine their efficiency on both desktop and embedded central processing units (CPUs). Parallel computing is a methodology employed in software development that enables certain segments of code to execute simultaneously, thereby diminishing the overall execution time of an application and augmenting its scalability. Contemporary processors boast a multi-core architecture, integrating multiple CPUs within a single chip, which is pivotal for facilitating parallelism\cite{modern_processors}.  

Parallelism can be achieved via multi-threading and multi-processing techniques. A process refers to an active instance of a computer program, encompassing the program's code and its ongoing activities. Each process operates within its distinct memory address space and system resources, maintaining independence from other processes. However, processes can engage in communication with one another through various inter-process communication (IPC) mechanisms. Conversely, a thread represents the minimal unit of processing within a process. It executes within a process's context, sharing the process’s resources like memory and file descriptors, yet it retains its distinct execution state, including the program counter, register set, and stack. Threads can facilitate the parallel execution of code segments within a single process\cite{multi_processing_multi_threading_article}.

Multi-processing involves an application initiating multiple processes to perform parallel operations, whereas multi-threading pertains to an application that generates multiple threads usually within a single process. This project concentrates on three main applications: the initial two are optimised utilizing multi-threading and their outcomes are assessed on both desktop and embedded processors. The embedded processors examined in this study include the Raspberry Pi 5, 4, and 3, with the Raspberry Pi 5 representing the forefront of technology as of 2024. The final application is a graphical user interface (GUI) application, where multi-processing is employed to attain parallelism. This application was developed by Alex Henneman, a Ph.D. student, under the supervision of Dr. Luciano Ost\cite{debate_fi_publication}. The aim here is to refine this application to minimize its execution time and enhance its scalability. 

The first objective of this project is to improve the \texttt{mpbenchmark} multi-core benchmark tool, which simulates jet engine thermodynamics to evaluate CPU performance \cite{mpbenchmark_paper}. \texttt{mpbenchmark} generates two key outputs: runtime and the number of deadlines missed, the latter indicating performance quality based on thread completion times. This tool builds upon its predecessor, \texttt{JetBench}, which was originally developed in \texttt{C} using \texttt{OpenMP} \cite{JetBench_paper}. The transition to \texttt{mpbenchmark} addresses \texttt{JetBench}'s limitations and extends support to other languages like \texttt{Ada}, \texttt{C\#}, and \texttt{Java}, with \texttt{C} and \texttt{Ada} showing the best performance. However, these versions face challenges such as \texttt{C}'s lack of object-orientation and manual memory management issues \cite{c_language_drawbacks}, and \texttt{Ada}'s limited use outside defense and aerospace \cite{ada_langauge_uses}. To overcome these, the project aims to develop \texttt{mpbenchmark} using \texttt{C++}, leveraging modern enhancements to improve functionality and efficiency since 2011.

The secondary objective of this project centres on enhancing the performance of \texttt{MobileNet}, a specialised machine learning algorithm within the realm of convolutional neural networks (\texttt{CNNs})\cite{mobilenet_paper}. \texttt{MobileNet} excels in the field of image classification, a process in which the algorithm is provided with an image and tasked with determining the image's corresponding class. While the intricate mathematical foundations and specific operational details of \texttt{MobileNet} are beyond the scope of this discussion, the primary focus is set on augmenting its efficiency. Originally designed as a sequential algorithm, \texttt{MobileNet} primarily operates on a single CPU core, which poses limitations on its execution speed and scalability. In pursuit of addressing these constraints, this project endeavours to transform the existing \texttt{C++} implementation of \texttt{MobileNet}\cite{mobilenet_repo} into a multi-threaded architecture. By doing so, the aim is to significantly decrease its runtime and enhance its scalability, thereby optimizing the algorithm's performance for more robust and efficient image classification tasks. This effort to transition \texttt{MobileNet} from a sequential to a multi-threaded model represents a strategic move to leverage the capabilities of modern multi-core processors, ensuring a more responsive and efficient computational process.

The project's third objective is dedicated to the optimisation of a graphical user interface (\texttt{GUI}) application designed for microcontroller (\texttt{MCU}) testing, with a focus on minimising application runtime and bolstering its scalability. Named the \texttt{DeBaTE-FI} platform\cite{debate_fi_publication}, this application is crafted in \texttt{Python} and leverages both multi-threading and multi-processing techniques to achieve parallelism and concurrency. It's crucial to distinguish between concurrency and parallelism; in a concurrent framework, tasks are initiated, executed, and completed in overlapping intervals, without necessitating simultaneous operation. The operational flow of the \texttt{DeBaTE-FI} platform involves the user connecting \texttt{MCUs} to a computer, after which the application dispatches specific commands to these \texttt{MCUs}. Following the transmission of commands, the platform awaits responses from the \texttt{MCUs} and proceeds to log the requisite data into output files. Among the three applications addressed in this project, the \texttt{DeBaTE-FI} platform emerges as the most intricate, a complexity attributable to both the scale and the sophisticated nature of its functions. This optimisation effort aims to streamline these extensive operations, enhancing the application's performance and user experience.

The structure of the report is organized as follows: it starts with a literature review, followed by methodology, results, and discussion sections. Appendices are provided after the conclusion for additional reference. The literature review section places the research within the existing body of knowledge by reviewing and interpreting relevant studies pertinent to the research question. This establishes a foundation for understanding the contributions of the project to the field. The methodology section outlines the strategies used to identify performance bottlenecks and potential optimization points within the software, including the introduction of new software designs. These are primarily illustrated through Unified Modeling Language (UML) diagrams and selected code snippets, offering a clear depiction of the proposed solutions. Following the methodology, the results and discussion sections report and analyse the findings from experiments conducted on both desktop and embedded processors, specifically targeting Raspberry Pi models 3 through 5. The findings are presented through benchmark runtime and speedup plots, providing a quantitative evaluation of the performance improvements. In the discussion section, the implications of these results are explored, evaluating the efficiency of the implemented optimizations and proposing directions for future research. This section seeks to provide an in-depth analysis that links the empirical findings with broader theoretical considerations. The appendices serve as a repository for supplementary materials, including details on the experimental PC setup, system specifications, and extended code snippets. These resources offer readers a deeper understanding of the technical aspects of the research, supporting the report's goals of transparency and reproducibility. 


\chapter{Literature review(6-10 pages)}
\input{literature_review.tex}


\chapter{Methodology(5-7 pages)}
\input{methodology.tex}

\chapter{Results and Discussion(8-10 pages)}
\input{results_and_discussion.tex}


\chapter{Conclusion(2 pages)}
% Your conclusion content here.
\input{conclusion.tex}

% Ensure bibliography starts on a new page and add it to the ToC.
\clearpage % Ensures bibliography starts on a new page.
\phantomsection % Ensures that the hyperlink anchor is correctly placed here.
\addcontentsline{toc}{chapter}{References}
\bibliographystyle{IEEEtran}
\bibliography{references} % Assumes your bibliography is in the 'references.bib' file.

% Ensure appendices start on a new page and add it to the ToC.
\newpage
\chapter{Appendices(Not completed)}
\begin{appendices}
	\input{appendix.tex}  % Assuming this file contains your appendices.
\end{appendices}


\end{document}



